// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"fmt"
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for CreateSessionRequestDifficulty.
const (
	Easy   CreateSessionRequestDifficulty = "easy"
	Hard   CreateSessionRequestDifficulty = "hard"
	Medium CreateSessionRequestDifficulty = "medium"
)

// Defines values for PhaseInfoPhaseType.
const (
	PhaseInfoPhaseTypeDiscussion    PhaseInfoPhaseType = "discussion"
	PhaseInfoPhaseTypeIntroduction  PhaseInfoPhaseType = "introduction"
	PhaseInfoPhaseTypeInvestigation PhaseInfoPhaseType = "investigation"
	PhaseInfoPhaseTypeReveal        PhaseInfoPhaseType = "reveal"
	PhaseInfoPhaseTypeVoting        PhaseInfoPhaseType = "voting"
)

// Defines values for PhaseResponsePhaseType.
const (
	PhaseResponsePhaseTypeDiscussion    PhaseResponsePhaseType = "discussion"
	PhaseResponsePhaseTypeIntroduction  PhaseResponsePhaseType = "introduction"
	PhaseResponsePhaseTypeInvestigation PhaseResponsePhaseType = "investigation"
	PhaseResponsePhaseTypeReveal        PhaseResponsePhaseType = "reveal"
	PhaseResponsePhaseTypeVoting        PhaseResponsePhaseType = "voting"
)

// CreateSessionRequest defines model for CreateSessionRequest.
type CreateSessionRequest struct {
	// Difficulty 難易度
	Difficulty CreateSessionRequestDifficulty `json:"difficulty"`

	// PlayerCount プレイヤー人数
	PlayerCount int `json:"playerCount"`
}

// CreateSessionRequestDifficulty 難易度
type CreateSessionRequestDifficulty string

// CreateSessionResponse defines model for CreateSessionResponse.
type CreateSessionResponse struct {
	InitialPhase PhaseInfo `json:"initialPhase"`

	// OwnerPlayerId セッションオーナーのプレイヤーID
	OwnerPlayerId openapi_types.UUID `json:"ownerPlayerId"`

	// PlayerIds 全プレイヤーのID
	PlayerIds []openapi_types.UUID `json:"playerIds"`

	// SessionId セッションID
	SessionId openapi_types.UUID `json:"sessionId"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Message エラーメッセージ
	Message string `json:"message"`
}

// PhaseInfo defines model for PhaseInfo.
type PhaseInfo struct {
	// Description フェーズの説明
	Description string `json:"description"`

	// Duration 推奨プレイ時間（分）
	Duration int `json:"duration"`

	// PhaseNumber フェーズ番号
	PhaseNumber int `json:"phaseNumber"`

	// PhaseType フェーズの種類
	PhaseType PhaseInfoPhaseType `json:"phaseType"`

	// PublicText 全プレイヤーに公開される情報
	PublicText string `json:"publicText"`
}

// PhaseInfoPhaseType フェーズの種類
type PhaseInfoPhaseType string

// PhaseResponse defines model for PhaseResponse.
type PhaseResponse struct {
	// AvailableActions このプレイヤーが実行可能なアクション
	AvailableActions []string `json:"availableActions"`

	// Description フェーズの説明
	Description string `json:"description"`

	// PhaseNumber フェーズ番号
	PhaseNumber int `json:"phaseNumber"`

	// PhaseType フェーズの種類
	PhaseType PhaseResponsePhaseType `json:"phaseType"`

	// PrivateText このプレイヤーだけに表示される情報
	PrivateText string `json:"privateText"`

	// PublicText 全プレイヤーに公開される情報
	PublicText string `json:"publicText"`
}

// PhaseResponsePhaseType フェーズの種類
type PhaseResponsePhaseType string

// ResultResponse defines model for ResultResponse.
type ResultResponse struct {
	// PlayerNames プレイヤーIDと名前のマッピング
	PlayerNames map[string]string `json:"playerNames"`

	// Truth 事件の真相
	Truth string `json:"truth"`

	// VotingResult プレイヤーIDごとの得票数
	VotingResult map[string]int `json:"votingResult"`

	// WinnerId 最も票を集めたプレイヤーのID
	WinnerId openapi_types.UUID `json:"winnerId"`

	// WinnerName 最も票を集めたプレイヤーの名前
	WinnerName string `json:"winnerName"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	// Message 成功メッセージ
	Message string `json:"message"`
}

// VoteRequest defines model for VoteRequest.
type VoteRequest struct {
	// TargetPlayerId 投票対象のプレイヤーID
	TargetPlayerId openapi_types.UUID `json:"targetPlayerId"`
}

// PlayerIdHeader defines model for PlayerIdHeader.
type PlayerIdHeader = openapi_types.UUID

// SessionIdParam defines model for SessionIdParam.
type SessionIdParam = openapi_types.UUID

// GetPhaseParams defines parameters for GetPhase.
type GetPhaseParams struct {
	// XPlayerId プレイヤーID
	XPlayerId PlayerIdHeader `json:"X-Player-Id"`
}

// AdvancePhaseParams defines parameters for AdvancePhase.
type AdvancePhaseParams struct {
	// XPlayerId プレイヤーID
	XPlayerId PlayerIdHeader `json:"X-Player-Id"`
}

// VoteParams defines parameters for Vote.
type VoteParams struct {
	// XPlayerId プレイヤーID
	XPlayerId PlayerIdHeader `json:"X-Player-Id"`
}

// CreateSessionJSONRequestBody defines body for CreateSession for application/json ContentType.
type CreateSessionJSONRequestBody = CreateSessionRequest

// VoteJSONRequestBody defines body for Vote for application/json ContentType.
type VoteJSONRequestBody = VoteRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// セッション作成
	// (POST /sessions)
	CreateSession(ctx echo.Context) error
	// 現在のフェーズ情報取得
	// (GET /sessions/{sessionId}/phase)
	GetPhase(ctx echo.Context, sessionId SessionIdParam, params GetPhaseParams) error
	// フェーズを進める
	// (POST /sessions/{sessionId}/phase/advance)
	AdvancePhase(ctx echo.Context, sessionId SessionIdParam, params AdvancePhaseParams) error
	// ゲーム結果取得
	// (GET /sessions/{sessionId}/result)
	GetResult(ctx echo.Context, sessionId SessionIdParam) error
	// 投票
	// (POST /sessions/{sessionId}/vote)
	Vote(ctx echo.Context, sessionId SessionIdParam, params VoteParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// CreateSession converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSession(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateSession(ctx)
	return err
}

// GetPhase converts echo context to params.
func (w *ServerInterfaceWrapper) GetPhase(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", ctx.Param("sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sessionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPhaseParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Player-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Player-Id")]; found {
		var XPlayerId PlayerIdHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Player-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Player-Id", valueList[0], &XPlayerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Player-Id: %s", err))
		}

		params.XPlayerId = XPlayerId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Player-Id is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPhase(ctx, sessionId, params)
	return err
}

// AdvancePhase converts echo context to params.
func (w *ServerInterfaceWrapper) AdvancePhase(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", ctx.Param("sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sessionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AdvancePhaseParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Player-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Player-Id")]; found {
		var XPlayerId PlayerIdHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Player-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Player-Id", valueList[0], &XPlayerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Player-Id: %s", err))
		}

		params.XPlayerId = XPlayerId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Player-Id is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdvancePhase(ctx, sessionId, params)
	return err
}

// GetResult converts echo context to params.
func (w *ServerInterfaceWrapper) GetResult(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", ctx.Param("sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sessionId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetResult(ctx, sessionId)
	return err
}

// Vote converts echo context to params.
func (w *ServerInterfaceWrapper) Vote(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "sessionId" -------------
	var sessionId SessionIdParam

	err = runtime.BindStyledParameterWithOptions("simple", "sessionId", ctx.Param("sessionId"), &sessionId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sessionId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params VoteParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Player-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Player-Id")]; found {
		var XPlayerId PlayerIdHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Player-Id, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Player-Id", valueList[0], &XPlayerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Player-Id: %s", err))
		}

		params.XPlayerId = XPlayerId
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Player-Id is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.Vote(ctx, sessionId, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/sessions", wrapper.CreateSession)
	router.GET(baseURL+"/sessions/:sessionId/phase", wrapper.GetPhase)
	router.POST(baseURL+"/sessions/:sessionId/phase/advance", wrapper.AdvancePhase)
	router.GET(baseURL+"/sessions/:sessionId/result", wrapper.GetResult)
	router.POST(baseURL+"/sessions/:sessionId/vote", wrapper.Vote)

}
